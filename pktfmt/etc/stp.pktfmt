%%
#![allow(missing_docs)]
#![allow(unused_parens)]

use byteorder::{ByteOrder, NetworkEndian};

use crate::ether::{EtherAddr, EtherType};
use crate::{Buf, PktBuf, PktBufMut};
use crate::{Cursor, CursorMut};
%%

message StpTcnBpdu {
    header = [
        proto_id = Field {bit = 16, default=@0x00},
        version = Field {bit = 8, default=@0x0},
        type_ = Field {bit = 8, default=@0x80},
    ]
}

message StpConfBpdu {
    header = [
        proto_id = Field {bit = 16, default=@0x00},
        version = Field {bit = 8, default=@0x0},
        type_ = Field {bit = 8, default=@0x0},
        flag = Field {bit = 8},
        root_id = Field {bit = 64},
        path_cost = Field {bit = 32},
        bridge_id = Field {bit = 64},
        port_id = Field {bit = 16},
        msg_age = Field {bit = 16},
        max_age = Field {bit = 16},
        hello_time = Field {bit = 16},
        forward_delay = Field {bit = 16}
    ]
}

message RstpConfBpdu {
    header = [
        proto_id = Field {bit = 16, default=@0x00},
        version = Field {bit = 8, default=@0x2},
        type_ = Field {bit = 8, default=@0x2},
        flag = Field {bit = 8, gen=false},
        root_id = Field {bit = 64, gen=false},
        path_cost = Field {bit = 32, gen=false},
        bridge_id = Field {bit = 64, gen=false},
        port_id = Field {bit = 16, gen=false},
        msg_age = Field {bit = 16, gen=false},
        max_age = Field {bit = 16, gen=false},
        hello_time = Field {bit = 16, gen=false},
        forward_delay = Field {bit = 16, gen=false},
        version1_len = Field {bit=8, default=@0}
    ]
}

%%
impl<T: AsRef<[u8]>> RstpConfBpduMessage<T> {
    /// Get the `StpConfBpduMessage` part of the `RstpConfBpduMessage`.
    ///
    /// Stp protocol is a layered protocol. The `RstpConfBpduMessage` contains
    /// the `StpConfBpduMessage`, which is the first 35 bytes. This method
    /// retrieves the `StpConfBpduMessage` part.
    ///
    /// # Panics
    ///
    /// This method panics if `self.buf.len() < 35`.
    #[inline]
    pub fn stp_conf_bpdu_part(&self) -> StpConfBpduMessage<&[u8]> {
        StpConfBpduMessage::parse_unchecked(&self.buf.as_ref()[..35])
    }
}
impl<T: AsMut<[u8]>> RstpConfBpduMessage<T> {
    /// Get the mutable `StpConfBpduMessage` part of the `RstpConfBpduMessage`.
    ///
    /// Stp protocol is a layered protocol. The `RstpConfBpduMessage` contains
    /// the `StpConfBpduMessage`, which is the first 35 bytes. This method
    /// retrieves the mutable `StpConfBpduMessage` part.
    ///
    /// # Panics
    ///
    /// This method panics if `self.buf.len() < 35`.
    #[inline]
    pub fn stp_conf_bpdu_part_mut(&mut self) -> StpConfBpduMessage<&mut [u8]> {
        StpConfBpduMessage::parse_unchecked(&mut self.buf.as_mut()[..35])
    }
}

%%

message MstpConfBpdu {
    header = [
        proto_id = Field {bit = 16, default=@0x00},
        version = Field {bit = 8, default=@0x3},
        type_ = Field {bit = 8, default=@0x2},
        flag = Field {bit = 8, gen=false},
        root_id = Field {bit = 64, gen=false},
        path_cost = Field {bit = 32, gen=false},
        bridge_id = Field {bit = 64, gen=false},
        port_id = Field {bit = 16, gen=false},
        msg_age = Field {bit = 16, gen=false},
        max_age = Field {bit = 16, gen=false},
        hello_time = Field {bit = 16, gen=false},
        forward_delay = Field {bit = 16, gen=false},
        version1_len = Field {bit=8, default=@0, gen=false},
        version3_len = Field {bit = 16, default=64, gen=false},
        mst_config_format_selector = Field {bit = 8},
        mst_config_name = Field {bit = 256, repr=&[u8]},
        mst_config_revision = Field {bit = 16},
        mst_config_digest = Field {bit = 128, repr=&[u8]},
        irpc = Field {bit = 32},
        cist_bridge_id = Field {bit = 64},
        remain_id = Field {bit = 8}
    ],
    length = [
        header_len = version3_len + 38,
    ]
}

%%
impl<T: AsRef<[u8]>> MstpConfBpduMessage<T> {
    /// Get the number of the `MstiConfMessage` contained in the
    /// `MstpConfBpduMessage`.
    ///
    /// This method returns `None` if the `MstpConfBpduMessage` has an invalid
    /// format.
    #[inline]
    pub fn num_of_msti_msg(&self) -> Option<usize> {
        if (self.header_len() - 102) % 16 != 0 {
            None
        } else {
            Some(((self.header_len() - 102) / 16) as usize)
        }
    }

    /// Get the `RstpConfBpduMessage` part of the `MstpConfBpduMessage`.
    ///
    /// Stp protocol is a layered protocol. `MstpConfBpduMessage` contains the
    /// `RstpConfBpduMessage`, which is the first 36 bytes. This method
    /// retrieves the `RstpConfBpduMessage` part.
    ///
    /// # Panics
    ///
    /// This method panics if `self.buf.len() < 36`.
    #[inline]
    pub fn rstp_conf_bpdu_part(&self) -> RstpConfBpduMessage<&[u8]> {
        RstpConfBpduMessage::parse_unchecked(&self.buf.as_ref()[..36])
    }

    /// Get the `index`-th `MstiConfMessage` from the `MstpConfBpduMessage`.
    ///
    /// # Panics
    ///
    /// This method panics if `MstpConfBpduMessage` does not have the `index`-th
    /// `MstiConfMessage`.
    #[inline]
    pub fn msti_conf_message(&self, index: usize) -> MstiConfMessage<&[u8]> {
        let offset = 16 * index;
        MstiConfMessage::parse_unchecked(&self.buf.as_ref()[102 + offset..118 + offset])
    }
}
impl<T: AsRef<[u8]> + AsMut<[u8]>> MstpConfBpduMessage<T> {
    /// Set the number of the `MstiConfMessage` contained in the
    /// `MstpConfBpduMessage`.
    #[inline]
    pub fn set_num_of_msti_msg(&mut self, num: u32) {
        self.set_header_len(102 + num * 16);
    }

    /// Get the mutable `RstpConfBpduMessage` part of the `MstpConfBpduMessage`.
    ///
    /// Stp protocol is a layered protocol. `MstpConfBpduMessage` contains the
    /// `RstpConfBpduMessage`, which is the first 36 bytes. This method
    /// retrieves the mutable `RstpConfBpduMessage`  part.
    ///
    /// # Panics
    ///
    /// This method panics if `self.buf.len() < 36`.
    #[inline]
    pub fn rstp_conf_bpdu_part_mut(&mut self) -> RstpConfBpduMessage<&mut [u8]> {
        RstpConfBpduMessage::parse_unchecked(&mut self.buf.as_mut()[..36])
    }

    /// Get the `index`-th mutable `MstiConfMessage` from the
    /// `MstpConfBpduMessage`.
    ///
    /// # Panics
    ///
    /// This method panics if `MstpConfBpduMessage` does not have the `index`-th
    /// `MstiConfMessage`.
    #[inline]
    pub fn msti_conf_message_mut(&mut self, index: usize) -> MstiConfMessage<&mut [u8]> {
        let offset = 16 * index;
        MstiConfMessage::parse_unchecked(&mut self.buf.as_mut()[102 + offset..118 + offset])
    }
}
%%

message MstiConf {
    header = [
        flags = Field {bit = 8},
        regional_root_id = Field {bit = 64},
        path_cost = Field {bit = 32},
        bridge_priority = Field {bit = 8},
        port_priority = Field {bit = 8},
        remaining_hops = Field {bit = 8},
    ]
}