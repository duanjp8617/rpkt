%%
#![allow(missing_docs)]
#![allow(unused_parens)]

use crate::ether::EtherAddr;

use super::{StpType, StpVersion};
%%

message StpTcnBpdu {
    header = [
        proto_id = Field {bit = 16, default=@0x00},
        version = Field {bit = 8, arg = %%StpVersion%%, default=@0x0},
        type_ = Field {bit = 8, arg = %%StpType%%, default=@0x80},
    ]
}

message StpConfBpdu {
    header = [
        proto_id = Field {bit = 16, default=@0x00},
        version = Field {bit = 8, arg = %%StpVersion%%, default=@0x0},
        type_ = Field {bit = 8, arg = %%StpType%%, default=@0x0},
        flag = Field {bit = 8},
        root_priority = Field {bit = 4, gen = false},
        root_sys_id_ext = Field {bit = 12},
        root_mac_addr = Field {bit = 48, repr = &[u8], arg = %%EtherAddr%%},
        path_cost = Field {bit = 32},        
        bridge_priority = Field {bit = 4, gen=false},
        bridge_sys_id_ext = Field {bit = 12},
        bridge_mac_addr = Field {bit = 48, repr = &[u8], arg = %%EtherAddr%%},
        port_id = Field {bit = 16},
        msg_age = Field {bit = 16, net_endian=false},
        max_age = Field {bit = 16, net_endian=false},
        hello_time = Field {bit = 16, net_endian=false},
        forward_delay = Field {bit = 16, net_endian=false}
    ]
}

%%
impl<T: AsRef<[u8]>> StpConfBpduMessage<T> {
    /// Get the root id priority from the `StpConfBpduMessage`.
    ///
    /// Note: the result is a a multiple of 4096.
    #[inline]
    pub fn root_priority(&self) -> u16 {
        ((self.buf.as_ref()[5] >> 4) as u16) << 12
    }

    /// Get the bridge id priority from the `StpConfBpduMessage`.
    ///
    /// Note: the result is a a multiple of 4096.
    #[inline]
    pub fn bridge_priority(&self) -> u16 {
        ((self.buf.as_ref()[17] >> 4) as u16) << 12
    }

    /// Get the root id as `u64`.
    #[inline]
    pub fn root_id(&self) -> u64 {
        u64::from_be_bytes((&self.buf.as_ref()[5..13]).try_into().unwrap())
    }

    /// Get the bridge id as `u64`.
    #[inline]
    pub fn bridge_id(&self) -> u64 {
        u64::from_be_bytes((&self.buf.as_ref()[17..25]).try_into().unwrap())
    }
}
impl<T: AsRef<[u8]> + AsMut<[u8]>> StpConfBpduMessage<T> {
    /// Set the root priority for the `StpConfBpduMessage`.
    ///
    /// Note: the input `value` must be a multiple of 4096.
    ///
    /// # Panics
    ///
    /// The lower 12 bits of `value` is not all zero.
    #[inline]
    pub fn set_root_priority(&mut self, value: u16) {
        assert!(value & 0x0fff == 0);
        let value = (value >> 12) as u8;
        self.buf.as_mut()[5] = (self.buf.as_mut()[5] & 0x0f) | (value << 4);
    }

    /// Set the bridge priority for the `StpConfBpduMessage`.
    ///
    /// Note: the input `value` must be a multiple of 4096.
    ///
    /// # Panics
    ///
    /// The lower 12 bits of `value` is not all zero.
    #[inline]
    pub fn set_bridge_priority(&mut self, value: u16) {
        assert!(value & 0x0fff == 0);
        let value = (value >> 12) as u8;
        self.buf.as_mut()[17] = (self.buf.as_mut()[17] & 0x0f) | (value << 4);
    }

    /// Set the root id from `value`.
    #[inline]
    pub fn set_root_id(&mut self, value: u64) {
        (&mut self.buf.as_mut()[5..13]).copy_from_slice(&value.to_be_bytes());
    }

    /// Set the bridge id from `value`.
    #[inline]
    pub fn set_bridge_id(&mut self, value: u64) {
        (&mut self.buf.as_mut()[17..25]).copy_from_slice(&value.to_be_bytes());
    }
}
%%

message RstpConfBpdu {
    header = [
        proto_id = Field {bit = 16, default=@0x00},
        version = Field {bit = 8, arg = %%StpVersion%%, default=@0x2},
        type_ = Field {bit = 8, arg = %%StpType%%, default=@0x2},
        flag = Field {bit = 8, gen=false},
        root_id = Field {bit = 64, repr = &[u8], arg = %%BridgeId%%, gen=false},
        path_cost = Field {bit = 32, gen=false},
        bridge_id = Field {bit = 64, repr = &[u8], arg = %%BridgeId%%, gen=false},
        port_id = Field {bit = 16, gen=false},
        msg_age = Field {bit = 16, gen=false},
        max_age = Field {bit = 16, gen=false},
        hello_time = Field {bit = 16, gen=false},
        forward_delay = Field {bit = 16, gen=false},
        version1_len = Field {bit=8, default=@0}
    ]
}

%%
impl<T: AsRef<[u8]>> RstpConfBpduMessage<T> {
    /// Get the `StpConfBpduMessage` part of the `RstpConfBpduMessage`.
    ///
    /// Stp protocol is a layered protocol. The `RstpConfBpduMessage` contains
    /// the `StpConfBpduMessage`, which is the first 35 bytes. This method
    /// retrieves the `StpConfBpduMessage` part.
    ///
    /// # Panics
    ///
    /// This method panics if `self.buf.len() < 35`.
    #[inline]
    pub fn stp_conf_bpdu_part(&self) -> StpConfBpduMessage<&[u8]> {
        StpConfBpduMessage::parse_unchecked(&self.buf.as_ref()[..35])
    }
}
impl<T: AsMut<[u8]>> RstpConfBpduMessage<T> {
    /// Get the mutable `StpConfBpduMessage` part of the `RstpConfBpduMessage`.
    ///
    /// Stp protocol is a layered protocol. The `RstpConfBpduMessage` contains
    /// the `StpConfBpduMessage`, which is the first 35 bytes. This method
    /// retrieves the mutable `StpConfBpduMessage` part.
    ///
    /// # Panics
    ///
    /// This method panics if `self.buf.len() < 35`.
    #[inline]
    pub fn stp_conf_bpdu_part_mut(&mut self) -> StpConfBpduMessage<&mut [u8]> {
        StpConfBpduMessage::parse_unchecked(&mut self.buf.as_mut()[..35])
    }
}

%%

message MstpConfBpdu {
    header = [
        proto_id = Field {bit = 16, default=@0x00},
        version = Field {bit = 8, arg = %%StpVersion%%, default=@0x3},
        type_ = Field {bit = 8, arg = %%StpType%%, default=@0x2},
        flag = Field {bit = 8, gen=false},
        root_id = Field {bit = 64, repr = &[u8], arg = %%BridgeId%%, gen=false},
        path_cost = Field {bit = 32, gen=false},
        bridge_id = Field {bit = 64, repr = &[u8], arg = %%BridgeId%%, gen=false},
        port_id = Field {bit = 16, gen=false},
        msg_age = Field {bit = 16, gen=false},
        max_age = Field {bit = 16, gen=false},
        hello_time = Field {bit = 16, gen=false},
        forward_delay = Field {bit = 16, gen=false},
        version1_len = Field {bit=8, default=@0, gen=false},
        version3_len = Field {bit = 16, default=64, gen=false},
        mst_config_format_selector = Field {bit = 8},
        mst_config_name = Field {bit = 256, repr=&[u8]},
        mst_config_revision = Field {bit = 16},
        mst_config_digest = Field {bit = 128, repr=&[u8]},
        irpc = Field {bit = 32},
        cist_bridge_id = Field {bit = 64, repr = &[u8], arg = %%BridgeId%%},
        remain_id = Field {bit = 8}
    ],
    length = [
        header_len = version3_len + 38,
    ]
}

%%
impl<T: AsRef<[u8]>> MstpConfBpduMessage<T> {
    /// Get the number of the `MstiConfMessage` contained in the
    /// `MstpConfBpduMessage`.
    ///
    /// This method returns `None` if the `MstpConfBpduMessage` has an invalid
    /// format.
    #[inline]
    pub fn num_of_msti_msg(&self) -> Option<usize> {
        if (self.header_len() - 102) % 16 != 0 {
            None
        } else {
            Some(((self.header_len() - 102) / 16) as usize)
        }
    }

    /// Get the `RstpConfBpduMessage` part of the `MstpConfBpduMessage`.
    ///
    /// Stp protocol is a layered protocol. `MstpConfBpduMessage` contains the
    /// `RstpConfBpduMessage`, which is the first 36 bytes. This method
    /// retrieves the `RstpConfBpduMessage` part.
    ///
    /// # Panics
    ///
    /// This method panics if `self.buf.len() < 36`.
    #[inline]
    pub fn rstp_conf_bpdu_part(&self) -> RstpConfBpduMessage<&[u8]> {
        RstpConfBpduMessage::parse_unchecked(&self.buf.as_ref()[..36])
    }

    /// Get the `index`-th `MstiConfMessage` from the `MstpConfBpduMessage`.
    ///
    /// # Panics
    ///
    /// This method panics if `MstpConfBpduMessage` does not have the `index`-th
    /// `MstiConfMessage`.
    #[inline]
    pub fn msti_conf_message(&self, index: usize) -> MstiConfMessage<&[u8]> {
        let offset = 16 * index;
        MstiConfMessage::parse_unchecked(&self.buf.as_ref()[102 + offset..118 + offset])
    }
}
impl<T: AsRef<[u8]> + AsMut<[u8]>> MstpConfBpduMessage<T> {
    /// Set the number of the `MstiConfMessage` contained in the
    /// `MstpConfBpduMessage`.
    #[inline]
    pub fn set_num_of_msti_msg(&mut self, num: u32) {
        self.set_header_len(102 + num * 16);
    }

    /// Get the mutable `RstpConfBpduMessage` part of the `MstpConfBpduMessage`.
    ///
    /// Stp protocol is a layered protocol. `MstpConfBpduMessage` contains the
    /// `RstpConfBpduMessage`, which is the first 36 bytes. This method
    /// retrieves the mutable `RstpConfBpduMessage`  part.
    ///
    /// # Panics
    ///
    /// This method panics if `self.buf.len() < 36`.
    #[inline]
    pub fn rstp_conf_bpdu_part_mut(&mut self) -> RstpConfBpduMessage<&mut [u8]> {
        RstpConfBpduMessage::parse_unchecked(&mut self.buf.as_mut()[..36])
    }

    /// Get the `index`-th mutable `MstiConfMessage` from the
    /// `MstpConfBpduMessage`.
    ///
    /// # Panics
    ///
    /// This method panics if `MstpConfBpduMessage` does not have the `index`-th
    /// `MstiConfMessage`.
    #[inline]
    pub fn msti_conf_message_mut(&mut self, index: usize) -> MstiConfMessage<&mut [u8]> {
        let offset = 16 * index;
        MstiConfMessage::parse_unchecked(&mut self.buf.as_mut()[102 + offset..118 + offset])
    }
}
%%

message MstiConf {
    header = [
        flags = Field {bit = 8},
        regional_root_id = Field {bit = 64, repr = &[u8], arg = %%BridgeId%%},
        path_cost = Field {bit = 32},
        bridge_priority = Field {bit = 8},
        port_priority = Field {bit = 8},
        remaining_hops = Field {bit = 8},
    ]
}

%%
#[derive(Debug)]
pub enum StpMessageGroup<T> {
    StpTcn(StpTcnBpduMessage<T>),
    StpConf(StpConfBpduMessage<T>),
    RstpConf(RstpConfBpduMessage<T>),
    MstpConf(MstpConfBpduMessage<T>),
}
impl<T: AsRef<[u8]>> StpMessageGroup<T> {
    pub fn group_parse(buf: T) -> Result<Self, T> {
        if buf.as_ref().len() < 3 {
            return Err(buf);
        }
        let v = buf.as_ref()[2];
        let t = buf.as_ref()[3];
        match (t, v) {
            (0, 0) => StpConfBpduMessage::parse(buf).map(|msg| StpMessageGroup::StpConf(msg)),
            (2, 2) => RstpConfBpduMessage::parse(buf).map(|msg| StpMessageGroup::RstpConf(msg)),
            (2, 3) => MstpConfBpduMessage::parse(buf).map(|msg| StpMessageGroup::MstpConf(msg)),
            (0x80, 0) => StpTcnBpduMessage::parse(buf).map(|msg| StpMessageGroup::StpTcn(msg)),
            _ => Err(buf),
        }
    }
}
%%