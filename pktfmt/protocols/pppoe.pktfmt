%%
#![allow(missing_docs)]
#![allow(unused_parens)]

use crate::{Buf, PktBuf, PktBufMut};
use crate::{Cursor, CursorMut};

use super::{PPPoECode, PPPoETagType};
%%

packet PPPoE {
    header = [
        version = Field{bit = 4, default=@1},
        type_ = Field{bit = 4, default=@1},
        code = Field{bit = 8, arg=%%PPPoECode%%},
        session_id = Field{bit = 16},
        len = Field{bit = 16, gen=false}
    ],
    length = [
        payload_len = len
    ]
}

%%
impl<T: PktBuf> PPPoEPacket<T> {
    /// Get PPP session's payload type and payload buffer from a PPPoE packet.
    ///
    /// The returned packet buffer only contains the PPP session payload, the
    /// payload type is removed from the buffer.
    ///
    /// # Panics
    /// This function panics if the `code` field is not 0 and the chunk length
    /// of the underlying packet buffer is smaller than 8.    
    pub fn session_payload(self) -> (u16, T) {
        assert!(self.code() == PPPoECode::SESSION && self.buf.chunk().len() >= 8);

        let data_type = u16::from_be_bytes((&self.buf.chunk()[6..8]).try_into().unwrap());
        let mut payload = self.payload();
        payload.advance(2);
        (data_type, payload)
    }
}

impl<T: PktBufMut> PPPoEPacket<T> {
    /// Prepend the payload type to the start of the payload buffer.
    ///
    /// The returned packet buffer contains the actual PPPoE session payload,
    /// which can be used to construct the final PPPoE packet.
    ///
    /// # Panics
    /// This function panics if `buf.chunk_headroom() < 2`.
    pub fn prepend_session_payload_type(mut buf: T, payload_type: u16) -> T {
        assert!(buf.chunk_headroom() >= 2);
        buf.move_back(2);
        (&mut buf.chunk_mut()[..2]).copy_from_slice(&payload_type.to_be_bytes());
        buf
    }
}
%%

message PPPoETag {
    header = [
        type_ = Field{bit = 16, arg=%%PPPoETagType%%, default=0},
        len = Field{bit = 16, default=4, gen = false}
    ],
    length = [
        header_len = len
    ]
}

%%
#[derive(Debug, Clone, Copy)]
pub struct PPPoETagMessageIter<'a> {
    buf: &'a [u8],
}

impl<'a> PPPoETagMessageIter<'a> {
    pub fn from_message_slice(message_slice: &'a [u8]) -> Self {
        Self { buf: message_slice }
    }

    pub fn buf(&self) -> &'a [u8] {
        self.buf
    }
}

impl<'a> Iterator for PPPoETagMessageIter<'a> {
    type Item = PPPoETagMessage<Cursor<'a>>;

    fn next(&mut self) -> Option<Self::Item> {
        match PPPoETagMessage::parse(self.buf) {
            Ok(msg) => {
                self.buf = &self.buf[msg.header_len() as usize..];
                Some(PPPoETagMessage {
                    buf: Cursor::new(&msg.buf()[..msg.header_len() as usize]),
                })
            }
            Err(_) => None,
        }
    }
}

#[derive(Debug)]
pub struct PPPoETagMessageIterMut<'a> {
    buf: &'a mut [u8],
}

impl<'a> PPPoETagMessageIterMut<'a> {
    pub fn from_message_slice_mut(message_slice_mut: &'a mut [u8]) -> Self {
        Self {
            buf: message_slice_mut,
        }
    }

    pub fn buf(&self) -> &[u8] {
        &self.buf[..]
    }
}

impl<'a> Iterator for PPPoETagMessageIterMut<'a> {
    type Item = PPPoETagMessage<CursorMut<'a>>;

    fn next(&mut self) -> Option<Self::Item> {
        match PPPoETagMessage::parse(&self.buf[..]) {
            Ok(msg) => {
                let header_len = msg.header_len() as usize;
                let (fst, snd) = std::mem::replace(&mut self.buf, &mut []).split_at_mut(header_len);
                self.buf = snd;
                Some(PPPoETagMessage {
                    buf: CursorMut::new(fst),
                })
            }
            Err(_) => None,
        }
    }
}
%%