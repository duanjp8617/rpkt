%%
#![allow(missing_docs)]
#![allow(unused_parens)]
#![allow(unreachable_patterns)]

use std::net::Ipv6Addr;

use crate::endian::{read_uint_from_be_bytes, write_uint_as_be_bytes};
use crate::ipv4::IpProtocol;
use crate::{Buf, PktBuf, PktBufMut};
use crate::{Cursor, CursorMut};
%%

packet Ipv6 {
    header = [
        version = Field{bit = 4, default = 6}, 
        traffic_class = Field{bit = 8},
        flow_label = Field {bit = 20},
        payload_len_ = Field{
            bit = 16,
            default = 0,
            gen = false
        },
        next_header = Field{bit = 8, arg = %%IpProtocol%%, default=4},
        hop_limit = Field{bit = 8},
        src_addr = Field{bit = 128, gen=false},
        dst_addr = Field{bit = 128, gen=false},
    ],
    length = [
        payload_len=payload_len_
    ]
}

%%
impl<T: Buf> Ipv6<T> {
    #[inline]
    pub fn src_addr(&self) -> Ipv6Addr {
        let b: [u8; 16] = (self.buf.chunk()[8..24].try_into().unwrap());
        b.into()
    }
    #[inline]
    pub fn dst_addr(&self) -> Ipv6Addr {
        let b: [u8; 16] = (self.buf.chunk()[24..40].try_into().unwrap());
        b.into()
    }
}

impl<T: PktBufMut> Ipv6<T> {
    #[inline]
    pub fn set_src_addr(&mut self, value: Ipv6Addr) {
        (&mut self.buf.chunk_mut()[8..24]).copy_from_slice(&value.octets());
    }
    #[inline]
    pub fn set_dst_addr(&mut self, value: Ipv6Addr) {
        (&mut self.buf.chunk_mut()[24..40]).copy_from_slice(&value.octets());
    }
}
%%

packet DestOptions {
    header = [
        next_header = Field{bit = 8, arg = %%IpProtocol%%, default=4},
        len = Field{bit = 8, default=0, gen=false}
    ],
    length = [
        header_len = 8*len + 8,
    ]
}

packet HopByHopOption {
    header = [
        next_header = Field{bit = 8, arg = %%IpProtocol%%, default=4},
        len = Field{bit = 8, default=0, gen=false}
    ],
    length = [
        header_len = 8*len + 8,
    ]
}

packet RoutingHeader {
    header = [
        next_header = Field{bit = 8, arg = %%IpProtocol%%, default=4},
        len = Field{bit = 8, default=0, gen=false},
        type_ = Field{bit = 8},
        segments_left = Field{bit = 8},
        type_specific_data = Field{bit = 32},
    ],
    length = [
        header_len = 8*len + 8,
    ]
}

packet FragmentHeader {
    header = [
        next_header = Field{bit = 8, arg = %%IpProtocol%%, default=4},
        reserved = Field{bit = 8, default=0},
        offset = Field{bit = 13},
        reserved1 = Field{bit = 2},
        more_frag = Field{bit = 1, arg = bool},
        ident = Field{bit = 32,}
    ]
}

packet AuthenticationHeader {
    header = [
        next_header = Field{bit = 8, arg = %%IpProtocol%%, default=4},
        len = Field{bit = 8, default=1, gen=false},
        reserved = Field{bit = 16},
        security_parameters_index = Field{bit = 32},
        seq_num_field = Field{bit = 32},
    ],
    length = [
        header_len = 4*len + 8,
    ]
}

packet Generic {
    header = [
        type_ = Field{bit = 8},
        len = Field{bit = 8, gen = false},
    ],
    length = [
        header_len = len+2
    ],
    cond = (type_ == 2..5 || 6..),
}

packet RouterAlert {
    header = [
        type_ = Field{bit = 8, default=@0x05},
        len = Field{bit = 8, default=@2, gen = false},
        router_alert = Field{bit = 16}
    ],
    length = [
        header_len = len+2
    ],
    cond = (type_ == 0x05),
}

packet Padn {
    header = [
        type_ = Field{bit = 8, default=@1},
        len = Field{bit = 8, gen = false},
    ],
    length = [
        header_len = len+2
    ],
    cond = (type_ == 1),
}

packet Pad0 {
    header = [
        type_ = Field{bit = 8, default=@0},        
    ],
    cond = (type_ == 0),
}

group Ipv6Options = {
    members = [
        Generic,
        RouterAlert,
        Padn,
        Pad0
    ],
    enable_iter = true,
}